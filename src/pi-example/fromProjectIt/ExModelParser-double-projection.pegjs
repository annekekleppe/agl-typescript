// Generated by the ProjectIt Language Generator.

// This file contains the input to the PEG.JS parser generator (see https://pegjs.org). The parser generator 
// is automatically called by the ProjectIt Language Generator and another file with the same name, but with
// extension ".js" is created. The ".js" file contains the actual parser.
// The file with extension ".pegjs" (this file) is stored in order for the parsing rules to be examined.

{
    let creator = require("./ExampleCreatorPartOfParser");
}
        
ExModel = name:variable ws "{" ws 
	entities:(Entity)* ws 
	methods:MethodList2? ws 
	"}" ws "//" ws "end" ws "of" ws name:variable ws 
	{ return creator.createExModel({name:name, entities:entities, methods:methods, name:name}); }

Entity = name:variable ws baseEntity:("base" ws baseEntitySub:EntityPiElemRef { return baseEntitySub; })? ws "{" ws 
	attributes:AttributeList3? ws 
	methods:MethodList4? ws 
	"}" ws 
	{ return creator.createEntity({name:name, baseEntity:baseEntity, attributes:attributes, methods:methods}); }

Attribute = name:variable ws ":" ws declaredType:TypePiElemRef ws 
	{ return creator.createAttribute({name:name, declaredType:declaredType}); }

Method = name:variable ws "(" ws parameters:ParameterList5? ws "):" ws declaredType:TypePiElemRef ws "{" ws 
	body:ExExpression ws 
	"}" ws 
	{ return creator.createMethod({name:name, parameters:parameters, declaredType:declaredType, body:body}); }

ExExpression = var0:LiteralExpression { return var0; }
    / var1:AbsExpression { return var1; }
    / var2:ParameterRef { return var2; }
    / var3:LoopVariableRef { return var3; }
    / var4:SumExpression { return var4; }
    / var5:MethodCallExpression { return var5; }
    / var6:IfExpression { return var6; }
    / var7:BinaryExpression { return var7; }

LiteralExpression = var0:StringLiteralExpression { return var0; }
    / var1:NumberLiteralExpression { return var1; }
    / var2:BooleanLiteralExpression { return var2; }

StringLiteralExpression = "'" ws value:stringLiteral ws "'" ws 
	{ return creator.createStringLiteralExpression({value:value}); }

AppliedFeature = var0:AttributeRef { return var0; }

AttributeRef = attribute:AttributePiElemRef ws 
	{ return creator.createAttributeRef({attribute:attribute}); }

NumberLiteralExpression = value:stringLiteral ws 
	{ return creator.createNumberLiteralExpression({value:value}); }

BooleanLiteralExpression = value:stringLiteral ws 
	{ return creator.createBooleanLiteralExpression({value:value}); }

AbsExpression = "|" ws expr:ExExpression ws "|" ws 
	{ return creator.createAbsExpression({expr:expr}); }

ParameterRef = parameter:ParameterPiElemRef ws appliedfeature:("." ws appliedfeatureSub:AppliedFeature { return appliedfeatureSub; })? ws 
	{ return creator.createParameterRef({parameter:parameter, appliedfeature:appliedfeature}); }

LoopVariableRef = variable:LoopVariablePiElemRef ws 
	{ return creator.createLoopVariableRef({variable:variable}); }

SumExpression = "sum" ws "from" ws variable:LoopVariable ws "=" ws from:ExExpression ws "to" ws to:ExExpression ws "of" ws body:ExExpression ws 
	{ return creator.createSumExpression({variable:variable, from:from, to:to, body:body}); }

LoopVariable = name:variable ws 
	{ return creator.createLoopVariable({name:name}); }

MethodCallExpression = methodDefinition:MethodPiElemRef ws "(" ws args:ExExpressionList6? ws ")" ws 
	{ return creator.createMethodCallExpression({methodDefinition:methodDefinition, args:args}); }

IfExpression = "(" ws condition:ExExpression ws "?" ws whenTrue:ExExpression ws ":" ws whenFalse:ExExpression ws ")" ws 
	{ return creator.createIfExpression({condition:condition, whenTrue:whenTrue, whenFalse:whenFalse}); }

BinaryExpression = var0:MultiplyExpression { return var0; }
    / var1:PlusExpression { return var1; }
    / var2:DivideExpression { return var2; }
    / var3:AndExpression { return var3; }
    / var4:OrExpression { return var4; }
    / var5:ComparisonExpression { return var5; }

MultiplyExpression = "(" ws left:ExExpression ws "*" ws right:ExExpression ws ")"
    { return creator.createMultiplyExpression({left: left, right: right}); }
    
PlusExpression = "(" ws left:ExExpression ws "+" ws right:ExExpression ws ")"
    { return creator.createPlusExpression({left: left, right: right}); }
    
DivideExpression = "(" ws left:ExExpression ws "/" ws right:ExExpression ws ")"
    { return creator.createDivideExpression({left: left, right: right}); }
    
AndExpression = "(" ws left:ExExpression ws "and" ws right:ExExpression ws ")"
    { return creator.createAndExpression({left: left, right: right}); }
    
OrExpression = "(" ws left:ExExpression ws "or" ws right:ExExpression ws ")"
    { return creator.createOrExpression({left: left, right: right}); }
    
ComparisonExpression = var0:LessThenExpression { return var0; }
    / var1:GreaterThenExpression { return var1; }
    / var2:EqualsExpression { return var2; }

LessThenExpression = "(" ws left:ExExpression ws "<" ws right:ExExpression ws ")"
    { return creator.createLessThenExpression({left: left, right: right}); }
    
GreaterThenExpression = "(" ws left:ExExpression ws ">" ws right:ExExpression ws ")"
    { return creator.createGreaterThenExpression({left: left, right: right}); }
    
EqualsExpression = "(" ws left:ExExpression ws "==" ws right:ExExpression ws ")"
    { return creator.createEqualsExpression({left: left, right: right}); }
    
Parameter = name:variable ws ":" ws declaredType:TypePiElemRef ws 
	{ return creator.createParameter({name:name, declaredType:declaredType}); }


EntityPiElemRef = name:variable
    { return creator.createEntityPiElemRef({name: name}); }

TypePiElemRef = name:variable
    { return creator.createTypePiElemRef({name: name}); }

AttributePiElemRef = name:variable
    { return creator.createAttributePiElemRef({name: name}); }

ParameterPiElemRef = name:variable
    { return creator.createParameterPiElemRef({name: name}); }

LoopVariablePiElemRef = name:variable
    { return creator.createLoopVariablePiElemRef({name: name}); }

MethodPiElemRef = name:variable
    { return creator.createMethodPiElemRef({name: name}); }

MethodList2 = head:Method tail:(v:Method { return v; })*
    { return [head].concat(tail); }

AttributeList3 = head:Attribute tail:(v:Attribute { return v; })*
    { return [head].concat(tail); }

MethodList4 = head:Method tail:(v:Method { return v; })*
    { return [head].concat(tail); }

ParameterList5 = head:Parameter tail:("," ws v:Parameter { return v; })*
    { return [head].concat(tail); }

ExExpressionList6 = head:ExExpression tail:("," ws v:ExExpression { return v; })*
    { return [head].concat(tail); }

ws "whitespace" = (([ \t\n\r]) / (SingleLineComment) / (MultiLineComment) )*
rws "required whitespace" = (([ \t\n\r]) / (SingleLineComment) / (MultiLineComment) )+

varLetter           = [a-zA-Z]
identifierChar      = [a-zA-Z0-9_$] // any char but not /.,!?@~%^&*-=+(){}"':;<>?[]\/
anyChar             = [*a-zA-Z0-9' /\-[\]+<>=#$_.,!?@~%^&*-=+(){}:;<>?]
number              = [0-9]

variable            = first:varLetter rest:identifierChar* { return first + rest.join(""); }
stringLiteral       = "\"" chars:anyChar* "\"" { return chars.join(""); }
numberLiteral       = nums:number+ { return Number.parseInt(nums.join("")); }
booleanLiteral      = "false" { return false; }
                    / "true" { return true; }

SingleLineComment
  = "//" (!LineTerminator SourceCharacter)*

LineTerminator
  = [\n\r\u2028\u2029]

Comment "comment"
  = MultiLineComment
  / SingleLineComment

MultiLineComment
  = "/*" (!"*/" SourceCharacter)* "*/"

SourceCharacter
  = .
  
char
  = unescaped
  / escape
    sequence:(
        '"'
      / "\\"
      / "/"
      / "\["
      / "\]"
      / "$"
      / "b" { return "\b"; }
      / "f" { return "\f"; }
      / "n" { return "\n"; }
      / "r" { return "\r"; }
      / "t" { return "\t"; }
      / "u" digits:$(HEXDIG HEXDIG HEXDIG HEXDIG) {
          return String.fromCharCode(parseInt(digits, 16));
        }
    )
    { return sequence; }

escape
  = "\\"

unescaped
  = [^\0-\x1F\x22\x5C]

// ----- Core ABNF Rules -----

// See RFC 4234, Appendix B (http://tools.ietf.org/html/rfc4234).
DIGIT  = [0-9]
HEXDIG = [0-9a-f]
