// This file contains the grammar for the ProjectIt Example project
// which is input to the AGL parser.
// It is a transformed version of the grammar that is generated by ProjectIt.
// Any errors could be either in the generation, the transformation to AGL format, or ...

namespace test
grammar PiExample {
    skip WHITE_SPACE = "\s+" ;
    skip MULTI_LINE_COMMENT = "/\*[^*]*\*+(?:[^*/][^*]*\*+)*/" ;
    skip SINGLE_LINE_COMMENT = "//[^\r\n]*" ;

ExModel = 'model' variable '{'
	Entity*
	'model' 'wide' 'Methods:'
	Method*
	'}' ;

Entity = 'Entity' variable OptionalBaseEntity? '{'
    Attribute*
    Method*
    '}' ;

OptionalBaseEntity = 'base' EntityPiElemRef ;

Attribute = variable ':' TypePiElemRef;

Method = 'method' variable '(' [Parameter / ',']* '):' TypePiElemRef '{'
	ExExpression
	'}' ;

Parameter = variable  ':'  TypePiElemRef;

ExExpression = LiteralExpression
    | AbsExpression
    | ParameterRef
    | LoopVariableRef
    | SumExpression
    | MethodCallExpression
    | IfExpression
    | BinaryExpression
    | GroupedExpression
    ;

LiteralExpression = StringLiteralExpression
    | NumberLiteralExpression
    | BooleanLiteralExpression ;

StringLiteralExpression = '"' stringLiteral '"';

NumberLiteralExpression = numberLiteral ;

BooleanLiteralExpression = booleanLiteral ;

AbsExpression = 'abs(' ExExpression ')' ;

ParameterRef = ParameterPiElemRef '.' AppliedFeature ;

AppliedFeature = AttributeRef ;

AttributeRef = AttributePiElemRef ;

LoopVariableRef = LoopVariablePiElemRef ;

SumExpression = 'sum' 'from' LoopVariable '=' ExExpression 'to' ExExpression 'of' ExExpression;

LoopVariable = variable;

MethodCallExpression = 'CALL' MethodPiElemRef '(' [ExExpression / ',']* ')' ;

IfExpression = 'if' ExExpression 'then'
ExExpression
'else'
ExExpression
'endif';

BinaryExpression = [ExExpression / operator]2+ ;

leaf operator = '*' | '/' | '+' | 'and' | 'or' | '<' | '>' | '==' ;

GroupedExpression = '(' ExExpression ')' ;


EntityPiElemRef = variable;

TypePiElemRef = variable;

AttributePiElemRef = variable;

ParameterPiElemRef = variable;

LoopVariablePiElemRef = variable;

MethodPiElemRef = variable;

anyChar             = ".";
number              = "[0-9]";

leaf variable            = "[a-zA-Z_][a-zA-Z0-9_]*" ;
/* https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java */
leaf stringLiteral       = "[^\"\\]*(\\.[^\"\\]*)*";
leaf numberLiteral       = number+;
leaf booleanLiteral      = 'false' | 'true';

}
