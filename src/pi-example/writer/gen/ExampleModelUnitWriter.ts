// Generated by the ProjectIt Language Generator.
// TODO import * as fs from "fs";
import { PiNamedElement, PiWriter } from "@projectit/core";
import {
    ExampleEveryConcept,
    PiElementReference,
    Demo,
    ExModel,
    Entity,
    Method,
    Attribute,
    AttributeType,
    Parameter,
    ExExpression,
    LiteralExpression,
    StringLiteralExpression,
    NumberLiteralExpression,
    BooleanLiteralExpression,
    AbsExpression,
    AppliedFeature,
    AttributeRef,
    ParameterRef,
    LoopVariable,
    LoopVariableRef,
    SumExpression,
    MethodCallExpression,
    IfExpression,
    BinaryExpression,
    MultiplyExpression,
    PlusExpression,
    DivideExpression,
    AndExpression,
    OrExpression,
    ComparisonExpression,
    LessThenExpression,
    GreaterThenExpression,
    EqualsExpression
} from "../../language/gen";

/**
 * SeparatorType is used to unparse lists.
 * NONE means only space(s) between the elements.
 * Terminator means that every element is terminated with a certain string.
 * Separator means that in between elements a certain string is placed.
 */
enum SeparatorType {
    NONE = "NONE",
    Terminator = "Terminator",
    Separator = "Separator"
}

/**
 * Class ExampleModelUnitWriter provides methods to return a string representation of an instance of
 * elements of language Example.
 * It is, amongst others, used to create error messages in the validator.
 */
export class ExampleModelUnitWriter implements PiWriter {
    output: string[] = []; // stores the result, one line per array element
    currentLine: number = 0; // keeps track of the element in 'output' that we are working on

    /**
     * Returns a string representation of 'modelelement'.
     * If 'short' is present and false, then a multi-line result will be given.
     * Otherwise, the result is always a single-line string, which is used in
     * error messages.
     * Note that the single-line-string cannot be parsed into a correct model.
     *
     * @param modelelement
     * @param startIndent
     * @param short
     */
    public writeToString(modelelement: ExampleEveryConcept, startIndent?: number, short?: boolean): string {
        this.writeToLines(modelelement, startIndent, short);
        return `${this.output
            .map(line => `${line}`)
            .join("\n")
            .trimRight()}`;
    }

    /**
     * Returns a string representation of 'modelelement', divided into an array of strings,
     * each of which contain a single line (without newline).
     * If 'short' is present and false, then a multi-line result will be given.
     * Otherwise, the result is always a single-line string.
     *
     * @param modelelement
     * @param startIndent
     * @param short
     */
    public writeToLines(modelelement: ExampleEveryConcept, startIndent?: number, short?: boolean): string[] {
        // set default for optional parameters
        if (startIndent === undefined) {
            startIndent = 0;
        }
        if (short === undefined) {
            short = true;
        }

        // make sure the global variables are reset
        this.output = [];
        this.currentLine = 0;

        // begin the unparsing with an indent if asked for
        let indentString: string = "";
        for (let _i = 0; _i < startIndent; _i++) {
            indentString += " ";
        }
        this.output[this.currentLine] = indentString;

        // do the actual work
        this.unparse(modelelement, short);
        return this.output;
    }

    private unparse(modelelement: ExampleEveryConcept, short: boolean) {
        if (modelelement instanceof EqualsExpression) {
            this.unparseEqualsExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof GreaterThenExpression) {
            this.unparseGreaterThenExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof LessThenExpression) {
            this.unparseLessThenExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof ComparisonExpression) {
            this.unparseComparisonExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof OrExpression) {
            this.unparseOrExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof AndExpression) {
            this.unparseAndExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof DivideExpression) {
            this.unparseDivideExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof PlusExpression) {
            this.unparsePlusExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof MultiplyExpression) {
            this.unparseMultiplyExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof BinaryExpression) {
            this.unparseBinaryExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof IfExpression) {
            this.unparseIfExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof MethodCallExpression) {
            this.unparseMethodCallExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof SumExpression) {
            this.unparseSumExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof LoopVariableRef) {
            this.unparseLoopVariableRef(modelelement, short);
            return;
        }
        if (modelelement instanceof ParameterRef) {
            this.unparseParameterRef(modelelement, short);
            return;
        }
        if (modelelement instanceof AttributeRef) {
            this.unparseAttributeRef(modelelement, short);
            return;
        }
        if (modelelement instanceof AbsExpression) {
            this.unparseAbsExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof BooleanLiteralExpression) {
            this.unparseBooleanLiteralExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof NumberLiteralExpression) {
            this.unparseNumberLiteralExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof StringLiteralExpression) {
            this.unparseStringLiteralExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof LiteralExpression) {
            this.unparseLiteralExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof LoopVariable) {
            this.unparseLoopVariable(modelelement, short);
            return;
        }
        if (modelelement instanceof AppliedFeature) {
            this.unparseAppliedFeature(modelelement, short);
            return;
        }
        if (modelelement instanceof ExExpression) {
            this.unparseExExpression(modelelement, short);
            return;
        }
        if (modelelement instanceof Parameter) {
            this.unparseParameter(modelelement, short);
            return;
        }
        if (modelelement instanceof AttributeType) {
            this.unparseAttributeType(modelelement, short);
            return;
        }
        if (modelelement instanceof Attribute) {
            this.unparseAttribute(modelelement, short);
            return;
        }
        if (modelelement instanceof Method) {
            this.unparseMethod(modelelement, short);
            return;
        }
        if (modelelement instanceof Entity) {
            this.unparseEntity(modelelement, short);
            return;
        }
        if (modelelement instanceof ExModel) {
            this.unparseExModel(modelelement, short);
            return;
        }
        if (modelelement instanceof Demo) {
            this.unparseDemo(modelelement, short);
            return;
        }
    }

    /**
     * See the public unparse method.
     */
    private unparseAttribute(modelelement: Attribute, short: boolean) {
        this.output[this.currentLine] += `${modelelement.name} `;
        this.output[this.currentLine] += `: `;
        this.output[this.currentLine] += `${modelelement.declaredType.name} `;
    }

    /**
     * See the public unparse method.
     */
    private unparseEntity(modelelement: Entity, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `Entity `;
        this.output[this.currentLine] += `${modelelement.name} `;
        if (!!modelelement.baseEntity) {
            this.output[this.currentLine] += `base `;
            if (!!modelelement.baseEntity) {
                this.output[this.currentLine] += `${modelelement.baseEntity.name} `;
            }
        }
        this.output[this.currentLine] += `{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.unparseList(modelelement.attributes, "\n", SeparatorType.Separator, true, this.output[this.currentLine].length, short);
            this.newlineAndIndentation(blockIndent + 4);
            this.unparseList(modelelement.methods, "\n", SeparatorType.Separator, true, this.output[this.currentLine].length, short);
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }

    /**
     * See the public unparse method.
     */
    private unparseExModel(modelelement: ExModel, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `model `;
        this.output[this.currentLine] += `${modelelement.name} `;
        this.output[this.currentLine] += `{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.unparseList(modelelement.entities, "\n", SeparatorType.Terminator, true, this.output[this.currentLine].length, short);
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `model wide Methods: `;
            this.newlineAndIndentation(blockIndent + 4);
            this.unparseList(modelelement.methods, "\n", SeparatorType.Separator, true, this.output[this.currentLine].length, short);
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }

    /**
     * See the public unparse method.
     */
    private unparseMethod(modelelement: Method, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `method `;
        this.output[this.currentLine] += `${modelelement.name} `;
        this.output[this.currentLine] += `( `;
        this.unparseList(modelelement.parameters, ",", SeparatorType.Separator, false, this.output[this.currentLine].length, short);
        this.output[this.currentLine] += `): `;
        this.output[this.currentLine] += `${modelelement.declaredType.name} `;
        this.output[this.currentLine] += `{ `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.unparse(modelelement.body, short);
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `} `;
        }
    }

    /**
     * See the public unparse method.
     */
    private unparseParameter(modelelement: Parameter, short: boolean) {
        this.output[this.currentLine] += `${modelelement.name} `;
        this.output[this.currentLine] += `: `;
        this.output[this.currentLine] += `${modelelement.declaredType.name} `;
    }

    /**
     * See the public unparse method.
     */
    private unparseMethodCallExpression(modelelement: MethodCallExpression, short: boolean) {
        this.output[this.currentLine] += `CALL `;
        this.output[this.currentLine] += `${modelelement.methodDefinition.name} `;
        this.output[this.currentLine] += `( `;
        this.unparseList(modelelement.args, ",", SeparatorType.Separator, false, this.output[this.currentLine].length, short);
        this.output[this.currentLine] += `) `;
    }

    /**
     * See the public unparse method.
     */
    private unparseSumExpression(modelelement: SumExpression, short: boolean) {
        this.output[this.currentLine] += `sum from `;
        this.unparse(modelelement.variable, short);
        this.output[this.currentLine] += `= `;
        this.unparse(modelelement.from, short);
        this.output[this.currentLine] += `to `;
        this.unparse(modelelement.to, short);
        this.output[this.currentLine] += `of `;
        this.unparse(modelelement.body, short);
    }

    /**
     * See the public unparse method.
     */
    private unparseLoopVariableRef(modelelement: LoopVariableRef, short: boolean) {
        this.output[this.currentLine] += `${modelelement.variable.name} `;
    }

    /**
     * See the public unparse method.
     */
    private unparseLoopVariable(modelelement: LoopVariable, short: boolean) {
        this.output[this.currentLine] += `${modelelement.name} `;
    }

    /**
     * See the public unparse method.
     */
    private unparseNumberLiteralExpression(modelelement: NumberLiteralExpression, short: boolean) {
        this.output[this.currentLine] += `${modelelement.value} `;
    }

    /**
     * See the public unparse method.
     */
    private unparseStringLiteralExpression(modelelement: StringLiteralExpression, short: boolean) {
        this.output[this.currentLine] += `' `;
        this.output[this.currentLine] += `"${modelelement.value}" `;
        this.output[this.currentLine] += `' `;
    }
    /**
     * See the public unparse method.
     */
    private unparsePlusExpression(modelelement: PlusExpression, short: boolean) {
        this.output[this.currentLine] += "( ";
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "+ ";
        this.unparse(modelelement.right, short);
        this.output[this.currentLine] += ") ";
    }
    /**
     * See the public unparse method.
     */
    private unparseMultiplyExpression(modelelement: MultiplyExpression, short: boolean) {
        this.output[this.currentLine] += "( ";
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "* ";
        this.unparse(modelelement.right, short);
        this.output[this.currentLine] += ") ";
    }
    /**
     * See the public unparse method.
     */
    private unparseDivideExpression(modelelement: DivideExpression, short: boolean) {
        this.output[this.currentLine] += "( ";
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "/ ";
        this.unparse(modelelement.right, short);
        this.output[this.currentLine] += ") ";
    }
    /**
     * See the public unparse method.
     */
    private unparseLessThenExpression(modelelement: LessThenExpression, short: boolean) {
        this.output[this.currentLine] += "( ";
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "< ";
        this.unparse(modelelement.right, short);
        this.output[this.currentLine] += ") ";
    }
    /**
     * See the public unparse method.
     */
    private unparseOrExpression(modelelement: OrExpression, short: boolean) {
        this.output[this.currentLine] += "( ";
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "or ";
        this.unparse(modelelement.right, short);
        this.output[this.currentLine] += ") ";
    }
    /**
     * See the public unparse method.
     */
    private unparseAndExpression(modelelement: AndExpression, short: boolean) {
        this.output[this.currentLine] += "( ";
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "and ";
        this.unparse(modelelement.right, short);
        this.output[this.currentLine] += ") ";
    }
    /**
     * See the public unparse method.
     */
    private unparseGreaterThenExpression(modelelement: GreaterThenExpression, short: boolean) {
        this.output[this.currentLine] += "( ";
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "> ";
        this.unparse(modelelement.right, short);
        this.output[this.currentLine] += ") ";
    }
    /**
     * See the public unparse method.
     */
    private unparseEqualsExpression(modelelement: EqualsExpression, short: boolean) {
        this.output[this.currentLine] += "( ";
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "== ";
        this.unparse(modelelement.right, short);
        this.output[this.currentLine] += ") ";
    }

    /**
     * See the public unparse method.
     */
    private unparseBooleanLiteralExpression(modelelement: BooleanLiteralExpression, short: boolean) {
        this.output[this.currentLine] += `${modelelement.value} `;
    }

    /**
     * See the public unparse method.
     */
    private unparseAttributeRef(modelelement: AttributeRef, short: boolean) {
        this.output[this.currentLine] += `${modelelement.attribute.name} `;
    }

    /**
     * See the public unparse method.
     */
    private unparseParameterRef(modelelement: ParameterRef, short: boolean) {
        this.output[this.currentLine] += `${modelelement.parameter.name} `;
        this.output[this.currentLine] += `. `;
        if (!!modelelement.appliedfeature) {
            this.unparse(modelelement.appliedfeature, short);
        }
    }

    /**
     * See the public unparse method.
     */
    private unparseIfExpression(modelelement: IfExpression, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `if `;
        this.unparse(modelelement.condition, short);
        this.output[this.currentLine] += ` then `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.unparse(modelelement.whenTrue, short);
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `else `;
            this.newlineAndIndentation(blockIndent + 4);
            this.unparse(modelelement.whenFalse, short);
            this.newlineAndIndentation(blockIndent + 0);
            this.output[this.currentLine] += `endif `;
        }
    }

    /**
     * See the public unparse method.
     */
    private unparseAbsExpression(modelelement: AbsExpression, short: boolean) {
        this.output[this.currentLine] += `abs( `;
        this.unparse(modelelement.expr, short);
        this.output[this.currentLine] += `) `;
    }
    /**
     * See the public unparse method.
     */
    private unparseBinaryExpression(modelelement: BinaryExpression, short: boolean) {
        this.output[this.currentLine] += "( ";
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "BinaryExpression ";
        this.unparse(modelelement.right, short);
        this.output[this.currentLine] += ") ";
    }
    /**
     * See the public unparse method.
     */
    private unparseComparisonExpression(modelelement: ComparisonExpression, short: boolean) {
        this.output[this.currentLine] += "( ";
        this.unparse(modelelement.left, short);
        this.output[this.currentLine] += "ComparisonExpression ";
        this.unparse(modelelement.right, short);
        this.output[this.currentLine] += ") ";
    }

    /**
     * See the public unparse method.
     */
    private unparseDemo(modelelement: Demo, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `Demo `;
        this.output[this.currentLine] += `${modelelement.name} `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `models `;
            this.newlineAndIndentation(blockIndent + 8);
            this.unparseList(modelelement.models, "", SeparatorType.Separator, true, this.output[this.currentLine].length, short);
        }
    }

    /**
     * See the public unparse method.
     */
    private unparseAttributeType(modelelement: AttributeType, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `AttributeType `;
        this.output[this.currentLine] += `${modelelement.name} `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `extra `;
            this.output[this.currentLine] += `${modelelement.extra} `;
        }
    }

    /**
     * See the public unparse method.
     */
    private unparseExExpression(modelelement: ExExpression, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `ExExpression `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `appliedfeature `;
            if (!!modelelement.appliedfeature) {
                this.unparse(modelelement.appliedfeature, short);
            }
        }
    }

    /**
     * See the public unparse method.
     */
    private unparseLiteralExpression(modelelement: LiteralExpression, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `LiteralExpression `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `appliedfeature `;
            if (!!modelelement.appliedfeature) {
                this.unparse(modelelement.appliedfeature, short);
            }
        }
    }

    /**
     * See the public unparse method.
     */
    private unparseAppliedFeature(modelelement: AppliedFeature, short: boolean) {
        const blockIndent = this.output[this.currentLine].length;
        // do the first line
        this.output[this.currentLine] += `AppliedFeature `;

        if (!short) {
            // do the rest of the lines as well
            this.newlineAndIndentation(blockIndent + 4);
            this.output[this.currentLine] += `appliedfeature `;
            if (!!modelelement.appliedfeature) {
                this.unparse(modelelement.appliedfeature, short);
            }
        }
    }

    /**
     * Adds a string representation of 'list' to the 'output', using 'sepText' , and 'sepType' to include either a separator string
     * or a terminator string. Param 'vertical' indicates whether the list should be represented vertically or horizontally.
     * If 'short' is false, then a multi-line result will be given. Otherwise, only one single-line string is added.
     * @param list
     * @param sepText
     * @param sepType
     * @param vertical
     * @param indent
     * @param short
     */
    private unparseList(
        list: ExampleEveryConcept[],
        sepText: string,
        sepType: SeparatorType,
        vertical: boolean,
        indent: number,
        short: boolean
    ) {
        list.forEach((listElem, index) => {
            const isLastInList: boolean = index === list.length - 1;
            this.unparse(listElem, short);
            this.doSeparatorOrTerminatorAndNewline(sepType, isLastInList, sepText, vertical, short, indent);
        });
    }

    /**
     * Adds a string representation of a list of references, where every reference
     * is replaced by the name of its referred element. The use of params
     * 'sepText' and 'SepType' are equals to those in the private method unparseList.
     * @param list
     * @param sepText
     * @param sepType
     * @param vertical
     * @param indent
     * @param short
     */
    private unparseReferenceList(
        list: PiElementReference<PiNamedElement>[],
        sepText: string,
        sepType: SeparatorType,
        vertical: boolean,
        indent: number,
        short: boolean
    ) {
        list.forEach((listElem, index) => {
            const isLastInList: boolean = index === list.length - 1;
            this.output[this.currentLine] += listElem.name;
            this.doSeparatorOrTerminatorAndNewline(sepType, isLastInList, sepText, vertical, short, indent);
        });
    }

    /**
     * Adds a string representation of 'list' to the 'output', using 'sepText' , and 'sepType' to include either a separator string
     * or a terminator string. Param 'vertical' indicates whether the list should be represented vertically or horizontally.
     * If 'short' is false, then a multi-line result will be given. Otherwise, only one single-line string is added.
     * @param list
     * @param sepText
     * @param sepType
     * @param vertical
     * @param indent
     * @param short
     */
    private unparseListOfPrimitiveValues(
        list: (string | number | boolean)[],
        sepText: string,
        sepType: SeparatorType,
        vertical: boolean,
        indent: number,
        short: boolean
    ) {
        list.forEach((listElem, index) => {
            const isLastInList: boolean = index === list.length - 1;
            if (typeof listElem === "string") {
                this.output[this.currentLine] += `"${listElem}"`;
            } else {
                this.output[this.currentLine] += `${listElem}`;
            }
            this.doSeparatorOrTerminatorAndNewline(sepType, isLastInList, sepText, vertical, short, indent);
        });
    }

    /**
     * Adds a separator text or a terminator text (followed by a newline and the right amount of indentation)
     * to the output, depending on the parameters.
     * @param sepType
     * @param isLastInList
     * @param sepText
     * @param vertical
     * @param short
     * @param indent
     */
    // tslint:disable-next-line:max-line-length
    private doSeparatorOrTerminatorAndNewline(
        sepType: SeparatorType,
        isLastInList: boolean,
        sepText: string,
        vertical: boolean,
        short: boolean,
        indent: number
    ) {
        // first eliminate any whitespace at the end of the line
        this.output[this.currentLine] = this.output[this.currentLine].trimRight();

        // then add the right separator or terminator
        switch (sepType) {
            case SeparatorType.Separator: {
                if (!isLastInList) {
                    this.output[this.currentLine] += sepText;
                }
                break;
            }
            case SeparatorType.Terminator: {
                this.output[this.currentLine] += sepText;
                break;
            }
        }

        // then add newline and indentation
        if (vertical && !isLastInList) {
            if (!short) {
                this.newlineAndIndentation(indent);
            } else {
                // stop after 1 line
                // note that the following cannot be parsed
                this.output[this.currentLine] += ` ...`;
                return;
            }
        }
    }

    /**
     * Makes a a new entry in the 'output' array
     * and adds the indentation of 'number' spaces
     * to the new entry/line.
     * @param indent
     */
    private newlineAndIndentation(indent: number) {
        this.currentLine += 1;
        let indentation: string = "";
        for (let _i = 0; _i < indent; _i++) {
            indentation += " ";
        }
        this.output[this.currentLine] = indentation;
    }
}
